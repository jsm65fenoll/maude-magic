[
  {
    "objectID": "maude-magic.html",
    "href": "maude-magic.html",
    "title": "maude-magic",
    "section": "",
    "text": "Refs: - pexpect - nbdev - IPython magics - Export examples - See persistent Shells.ipynb\n%%bash for package in pexpect nbdev jupyterlab-quarto do\npip list | grep “^\\(package *\" &gt; /dev/null && echo \"\\)package found” || pip install $package done # This must be done in terminal # nbdev_install_quarto",
    "crumbs": [
      "maude-magic"
    ]
  },
  {
    "objectID": "maude-magic.html#the-maude-interpreter-class",
    "href": "maude-magic.html#the-maude-interpreter-class",
    "title": "maude-magic",
    "section": "The Maude Interpreter class",
    "text": "The Maude Interpreter class\n\nsource\n\nMaudeInterpreter\n\ndef MaudeInterpreter(\n    debug:bool=False, trace:bool=False, timeout:int=3\n):\n\nControls maude execution, executing commands and print responses. Preserve sessions between different cell executions.\n\n\n\nCmd\n\ndef Cmd(\n    args:VAR_POSITIONAL, kwds:VAR_KEYWORD\n):\n\nSupport for flags\n\n\n\nTimeoutException\n\ndef TimeoutException(\n    \n):\n\nException raised if time-out.\n\ndef assert_print(result:tuple,type_=None,value_=None):\n    # print('result=',result)\n\n    if result:\n        if not result[1]: print(result[1])\n        elif type_ :  assert result[0] == type_,f\"Expecting type {type_} but {result[0]} found.\"\n        elif value_:  assert result[1] == value_,f\"Expecting value {value_} but {result[1]} found.\"    \n        else:         print(result)\n\nCreating maude interpreter:\nLoad a maude module. Show it and make some reduction:\n\nresult= maude('load SIMPLE-NAT .')\nassert_print(result)\n\nSkip quit command:\nClosing maude session on object destroy:",
    "crumbs": [
      "maude-magic"
    ]
  },
  {
    "objectID": "maude-magic.html#the-maude-magic-class",
    "href": "maude-magic.html#the-maude-magic-class",
    "title": "maude-magic",
    "section": "The maude Magic Class",
    "text": "The maude Magic Class\n\n\nload_ipython_extension\n\ndef load_ipython_extension(\n    ipython\n):\n\nAny module file that define a function named load_ipython_extension can be loaded via %load_ext module.path or be configured to be autoloaded by IPython at startup time.\n\n\n\nMaudeMagics\n\ndef MaudeMagics(\n    shell\n):\n\nAdapts Maude Shell to a IPython Magic class.Uses a owned Maude Shell. Cell magics are used to execute maude commands. Line magics are used for command line options.\nManually executing ‘load_ipython_extension’ for test purposes:\nNow, MaudeMagic uses an owned MaudeInterpreter to run maude commands:\n\n\nTest LOAD\n\n\nTest SHOW\n\nresult = %maude show module .\nassert_print(result)\n\n(None, 'SIMPLE-NAT is\\n sort Nat .\\n op zero : -&gt; Nat .\\n op s_ : Nat -&gt; Nat .\\n op _+_ : Nat Nat -&gt; Nat .\\n vars M N : Nat .\\n eq zero + N = N .\\n eq s N + M = s (N + M) .\\n\\n')\n\n\n\n\nTest REDUCE\n\nresult = %maude red s s 0 .\nassert_print(result,'Nat','s s 0')",
    "crumbs": [
      "maude-magic"
    ]
  },
  {
    "objectID": "maude-magic.html#use-cases-as-test",
    "href": "maude-magic.html#use-cases-as-test",
    "title": "maude-magic",
    "section": "Use cases as test",
    "text": "Use cases as test\nUtility function that test than a provided maude command is of sort Bool and value = True .\ndef assert_true(maude_command): result = %maude red { “http://perico.com” : “http://perico.com”,\n“http://perico.com” : [“http://perico.com”,“http://perico.com”] } :: ReverseMap . print(result) assert(‘result Bool: true’ in result)\nneed to access maude interpreter instance,\n\nRDF Dataset\nfth RDF-DATASET is\nsort RDF-Dataset .\n\nop &lt;_,_&gt; : UnnamedGraph NamedGraph* -&gt; RDF-Dataset [ctor] .    \nop NamedGraph : ResourceIdentifier Graph odeIdentifier    \n    \n    \n    \n    sort RDF-Document .\n\nop serializes : RDF-Dataset -&gt; JSON-LD-Document .\nop serializes : Property -&gt; IRI . \n\n\nsorts NamedGraph NamedGraph+ NamedGraph* .\n\n\n\n\n\nop serializes : Property -&gt; ResourceIdentifier .     \n\nop namedGraph : NodeIdentifier Graph -&gt; \nop _-[_]-&gt;_ : SourceNode IRI Node -&gt; Arc [ctor] . \n\n\nIRI BlankNodeId &lt; SourceNodeId &lt; NodeId Literal &lt; NodeId .   \n    \n\n\nJSON-LD\n\nJSON Syntax\nJSON-LD 1.1\n\nfmod JSON-SORTS is\n    sort Json \n    sorts  Object Array .\n    subsorts Object Array &lt; Json .    \n    sort Entry .    \n    op null : -&gt; Json [ctor] .    \nendfm         \n  \nview Json  from TRIV to JSON-SORTS is sort Elt to Json . endv\nview Entry from TRIV to JSON-SORTS is sort Elt to Entry . endv\n\nfmod JSON-ARRAY is\n    protecting LIST{Json} * ( op (__) to (_,_) ) .\n    op [_] : List{Json} -&gt; Array .\n    eq [nil] = null .\n    op [] : -&gt; Array [ctor] .\n    eq [] = null .    \nendfm\n\nfmod JSON-OBJECT is\n    protecting SET{Entry} .\n    op {_} : Set{Entry} -&gt; Object .\n    eq {empty} = null .    \n    \n    sorts Key Value .\n    op _:_ : Key Value  -&gt; Entry [ctor] .\nendfm        \n             \nfmod JSON is\n    extending JSON-SORTS .\n    protecting JSON-ARRAY .\n    protecting JSON-OBJECT .        \n    protecting STRING .\n\n    subsort String  &lt; Key Json .\n    subsort Json &lt; Value .\n        \nendfm\n\nNone\n\n\n\nresult = %maude red \"Juan\" : \"Perico\" .\nassert_print(result,'Entry')\n\n\nresult = %maude red \\\n{\\\n  \"name\" : \"Manu Sporny\" ,\\\n  \"homepage\" : \"http://manu.sporny.org/\" ,\\\n  \"image\" : \"http://manu.sporny.org/images/manu.png\"\\\n} .\nassert_print(result,\"Object\")\n\n\nresult = %maude red [\"Juan\",\"Perico\",\"Andres\"] .\nassert_print(result,'Array')\n\n\nresult = %maude red [\"Juan\",[\"Perico\",\"Andres\"]] .\nassert_print(result,'Array','[\"Juan\", [\"Perico\", \"Andres\"]]')\n\n\nresult = %maude red [\"Juan\", {\"Perico\" : \"Andres\"} ] .\nassert_print(result,'Array','[\"Juan\", {\"Perico\" : \"Andres\"}]')\n\n\nresult = %maude red {\"Juan\" : {\"Perico\" : \"Andres\"} } .\nassert_print(result,'Object','{\"Juan\" : {\"Perico\" : \"Andres\"}}')\n\n\nresult = %maude red {\"Juan\" : [\"Perico\", \"Andres\"]} .\nassert_print(result,'Object','{\"Juan\" : [\"Perico\", \"Andres\"]}')\n\n\nresult = %maude red \\\n{\\\n  \"name\" : \"Manu Sporny\",\\\n  \"homepage\" : \"http://manu.sporny.org/\",\\\n  \"image\" : \"http://manu.sporny.org/images/manu.png\"\\\n} .\nassert_print(result,'Object')\n\n\nresult = %maude red \\\n{\\\n  \"@context\" : {\\\n    \"name\" : \"http://schema.org/name\",\\\n    \"image\" : {\\\n      \"@id\" : \"http://schema.org/image\",\\\n      \"@type\" : \"@id\"\\\n    },\\\n    \"homepage\" : {\\\n      \"@id\" : \"http://schema.org/url\",\\\n      \"@type\" : \"@id\"\\\n    }\\\n  }\\\n} .\nassert_print(result,'Object')\n\n\n\nIRIS\nJSON-LD 1.1\n\nfmod IRI is\nprotecting STRING .\nsort IRI .\nsubsort IRI &lt; String .\ncmb S:String : IRI if find(S:String,\":\",0) :: NzNat .\nendfm\n\nNone\n\n\n\nresult = %maude red \"Http://perico\" .\nassert_print(result,'IRI',\"Http://perico\")\n\n\n\nKeywords\n\nfmod KEYWORD is\n    protecting STRING .\n    sort Keyword .\n    subsort Keyword &lt; String .\n    mb \"@context\"  : Keyword .\n    mb \"@id\"       : Keyword .\n    mb \"@context\"  : Keyword .\n    mb \"@id\"       : Keyword .\n    mb \"@included\" : Keyword .\n    mb \"@graph\"    : Keyword .\n    mb \"@nest\"     : Keyword .\n    mb \"@type\"     : Keyword .\n    mb \"@reverse\"  : Keyword .\n    mb \"@index\"    : Keyword .\nendfm\n\nNone\n\n\n\nresult = %maude red \"@context\" . \nassert_print(result,'Keyword',\"@context\")\n\n\n\nContext\n\nfmod CONTEXT is\n    protecting IRI .\n    extending JSON *( sort Object to Json-Object ) .\n        \n    sorts TermDef Context .\n    subsort TermDef &lt; Entry .\n    subsort Context &lt; Json-Object .\n        \n    sorts ContextKey ContextValue .\n    subsort String &lt; ContextKey &lt; Key .\n    subsorts IRI Json-Object &lt; ContextValue &lt; Value .\n\n    mb (K:ContextKey : V:ContextValue) : TermDef .\n    var ... : Set{Entry} . \n    cmb { T:TermDef , ...} : Context if {...} :: Context .\n    mb null : Context .\n        \nendfm\n\nNone\n\n\n\n#--- Example 4: Context for the sample document in the previous section\nresult = %maude red\\\n    \"name\" : \"http://schema.org/name\"\\\n    ***(This means that 'name' is shorthand for 'http://schema.org/name')\\\n.\nassert_print(result,'TermDef')\n\n\n#--- Example 4: Context for the sample document in the previous section\nresult = %maude red\\\n{\\\n    \"name\" : \"http://schema.org/name\"\\\n     ***(This means that 'name' is shorthand for 'http://schema.org/name')\\\n} .\nprint(result)\nassert('result Context:' in result)\n\nNone\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[33], line 4\n      2 result = get_ipython().run_line_magic('maude', 'red {     \"name\" : \"http://schema.org/name\"      ***(This means that \\'name\\' is shorthand for \\'http://schema.org/name\\') } .')\n      3 print(result)\n----&gt; 4 assert('result Context:' in result) \n\nTypeError: argument of type 'NoneType' is not iterable\n\n\n\n\n#--- Example 4: Context for the sample document in the previous section\nresult = %maude red { empty } .\nprint(result)\nassert('result Context:' in result)\n\n\n#--- Example 4: Context for the sample document in the previous section\nresult = %maude red\\\n{\\\n    \"@context\" : {\\\n        \"name\" : \"http://schema.org/name\",\\\n        ***(  This means that 'name' is shorthand for 'http://schema.org/name')\\\n        \"image\" : {\\\n            \"@id\" : \"http://schema.org/image\",\\\n            ***(  This means that 'image' is shorthand for 'http://schema.org/image')\\\n            \"@type\" : \"@id\"\\\n            ***( This means that a string value associated with 'image')\\\n            ***( should be interpreted as an identifier that is an IRI)\\\n            },\\\n        \"homepage\" : {\\\n            \"@id\" : \"http://schema.org/url\",\\\n            ***( This means that 'homepage' is shorthand for 'http://schema.org/url')\\\n            \"@type\" : \"@id\"\\\n            ***(  This means that a string value associated with 'homepage')\\\n            ***(  should be interpreted as an identifier that is an IRI )\\\n            }\\\n        }\\\n} .\nprint(result)\nassert('result Context:' in result)\n\n\n\nIdentifiers\nJSON-LD 1.1 / Node Objects\n\nfmod IDENTIFIER is\n    protecting STRING .\n    protecting IRI .\n    sorts BNI Compact-IRI Identifier .\n    subsorts IRI Compact-IRI BNI &lt; Identifier &lt; String .\n    var S : String .    \n    cmb S : IRI  if find(S,\":\",0) :: Nat .    \nendfm\n\n\nresult = %maude red friends:perico .\nassert_print(result,'IRI')\n\n\nfmod NODE-OBJECT-DECL is \nsort Node-Object .\nendfm\n\n\n\n\nGraph\n\nfmod GRAPH is \n    extending NODE-OBJECT-DECL .\n    extending JSON *( sort Object to Json-Object ) .\n\n    sorts Graph Named-Graph .\n    subsorts Node-Object Named-Graph &lt; Graph &lt; Array .    \n    subsort  Named-Graph &lt; Json-Object .\n    \n    mb null : Graph .\n    vars NObj NObj' NObj'' : Node-Object . var ... : List{Json} .  \n    var V : Value .  var .... : Set{Entry} . \n    var Ng : Named-Graph .\n     mb { \"@id\" : V, .... } : Named-Graph .\n    cmb [ NObj , ... ] : Graph if  [ ... ] :: Graph .\nendfm\n\n\nresult = %maude red \"@id\" : \"http://www.schema.org/graph\" .\nprint(result)   \nassert('result Entry:' in result)\n\n\nresult = %maude red .... :: Set{Entry} .\nprint(result)\nassert('result Bool: true' in result)\n\n\nresult = %maude red Ng :: Json .\nprint(result)\nassert('result Bool: true' in result)\n\n\nresult = %maude red { \"@id\" : \"http://www.schema.org/graph\", .... } .\nprint(result)\nassert('result Named-Graph:' in result)\n\n\nresult = %maude red [] . \nprint(result)\nassert('Graph: null' in result) \nresult = %maude red [NObj] . \nprint(result)\nassert('result Graph: [NObj]' in result) \nresult = %maude red [NObj, NObj' , NObj'' ] . \nprint(result)\nassert(\"result Graph: [NObj, NObj', NObj'']\" in result)\n\n\n\nReverse map\nJSON-LD 1.1 / Reverse Properties\nJSON-LD 1.1 / Node Object\n\nfmod REVERSE-MAP is \n    protecting IDENTIFIER .\n    extending NODE-OBJECT-DECL .\n    extending JSON *( sort Object to Map ) .\n\n    ***(If the node object contains the @reverse key,\n        its value (ReverseKeyValue) MUST be a map containing entries (ReverseProperty) \n        representing reverse properties)    \n    \n    sorts ReverseValue .\n    subsort ReverseValue &lt; Map . \n\n     mb { RP:ReverseProperty } : ReverseValue .\n    cmb { RP:ReverseProperty,Rest:NeSet{Entry} } : ReverseValue if { Rest:NeSet{Entry}} : ReverseValue .  \n\n    sort ReverseProperty .\n    subsort ReverseProperty &lt; Entry .    \n    sorts ReversePropertyValue .\n\n        \n    ***(Each value of such a reverse property (ReverseProperty) MUST be an IRI reference, a compact IRI, a blank node identifier, \n        a node object or an array containing a combination of these.)\n    \n    mb (ReversePropertyKey:IRI : V:ReversePropertyValue) : ReverseProperty .\n\n    subsorts Identifier Node-Object ReversePropertyValueArray  &lt; ReversePropertyValue . \n    \n    sort ReversePropertyValueArray .\n    \n    subsort ReversePropertyValueArray  &lt; Array .\n\n    var RPV : ReversePropertyValue . var .... : NeList{Json} . \n     mb [ RPV ] : ReversePropertyValueArray .       \n    cmb [ RPV , .... ] : ReversePropertyValueArray if [ .... ] :: ReversePropertyValueArray .   \n        \nendfm\n\n\nresult = %maude red  \"http://perico.com\"  . \nprint(result)\nassert(True) \nresult = %maude red  \"http://perico.com\" :: ReversePropertyValue . \nprint(result)\nassert(True) \nresult = %maude red  { \"http://perico.com\" : \"http://perico.com\" } :: ReverseValue . \nprint(result)\nassert('result Bool: true' in result) \nresult = %maude red  { \"http://perico.com\" : \"http://perico.com\", \\\n                       \"http://perico.com\" : \"http://perico.com\" } :: ReverseValue . \nprint(result)\nassert('result Bool: true' in result) \n\nresult = %maude red  [ \"http://perico.com\" ] . \nprint(result)\n\nresult = %maude red  [ \"http://perico.com\" , \"http://perico.com\" ] . \nprint(result)\n#assert('result Bool: true' in result) \n\n\n\n#assert('result Bool: true' in result)\n\n\nresult = %maude red \\\n{\\\n    \"http://example.com/vocab#parent\" : [\\\n      {\\\n        \"@id\" : \"#bart\",\\\n        \"http://example.com/vocab#name\" : \"Bart\"\\\n      }, {\\\n        \"@id\" : \"#lisa\",\\\n        \"http://example.com/vocab#name\" : \"Lisa\"\\\n      }\\\n    ]\\\n  } :: ReverseValue .\nprint(result)\nassert('result Bool: true' in result)\n\n\n\nNode Object\nJSON-LD 1.1 / Node Objects\n\nfmod NODE-OBJECT is\nprotecting KEYWORD .\nprotecting IDENTIFIER .\nprotecting JSON *( sort Object to Json-Object ) .\n\n    \n\nsorts Node-Object ^Node-Object .    \nsubsorts Node-Object ^Node-Object &lt; Object .\n\nsort Value .\n    \nvar O : Object . var  N : Node-Object .\nvar V : Value .    \ncmb O : ^Node-Object if\n        ({ \"@context\"  : V  , ...} := O and not V :: Context         )    \n     or ({ \"@id\"       : V  , ...} := O and not V :: Identifier      )\n     or ({ \"@graph\"    : V  , ...} := O and not V :: Graph           )\n     or ({ \"@type \"    : V  , ...} := O and not V :: Identifier      )\n     or ({ \"@reverse\"  : V  , ...} := O and not V :: Reverse-Map     ) \n     or ({ \"@included\" : V  , ...} := O and not V :: Included-Block  )\n     or ({ \"@index\"    : V  , ...} := O and not V :: String          )\n     or ({ \"@nest \"    : V  , ...} := O and not V :: Property-Nesting) .\n\ncmb O : Node-Object if not O :: ^Node-Object .\nendfm\n\n\n\nExpand\nfmod EXPAND is protecting CONTEXT .\nop xp : \n\nop merge : Object* Object* -&gt; Object* .\nop merge : Context Context -&gt; Context .\n\neq merge(nul,context) = context .\neq merge(context,nul) = context .\neq merge(term : value ,  (term : value', Object*))  = term : value', Object*  .\neq merge(term : value ,  Object*  = term : value, Object*  [owise] .\neq merge({Object,Object*},{Object*'}) = { merge(Object,Object*'),merge(Object*,Object*') } .     \nfmod\nfmod EXPAND is protecting JSON * ( sort Object to Context ) . protecting IDENTIFIER . protecting KEYWORD .\nsort IdOrKeyword . subsorts Identifier Keyword &gt; IdOrKeyword . # most-recently-defined-wins mechanism.\nop apply-context : Context Node-Object -&gt; Node-Object .\nop apply-context : Object* -&gt; Object . \n\nop merge-contexts : Context Context -&gt; Context . \n    \nce apply-context(Ctx,{ Object* }) = { apply-context(Ctx,Object*) } [owise] .\nce apply-context(Ctx,{ \"@context\" : Ctx', Object* }) = { apply-context(merge-context(Ctx,Ctx)) , Object* } \n\n\nTerms\n%%maude fmod TERM is protecting IRI . protecting Keyword .\nsort Identifier .\nsubsort Iri &lt; Identifier .\nsort IdOrKeyword .\nsubsorts Identifier Keyword &lt; IdOrKeyword .\n    \nsort Term .\nsubsort Term &lt; String .\nop expand : String Context -&gt; [URI] .\ncmb S:String : Term  if not S:String = \"\" \n                     /\\ not S:String :: URI  \n                     /\\ not S:String :: Keyword \n                     /\\ expand(S:String, Ctx:Context) :: IdOrKeyword .\n                     /\\ X:String :: Identifier or X:String :: Keyword .\nendfm\n\n\nJSON-LD BASIC\n%%maude fmod JSON-LD-BASIC is protecting JSON * (sort Pair to Entry, sort Pair+ to Entry+, sort Pair* to Entry*, sort Json to Value) .\n------------------------\nsorts Term IRI Keyword .\n------------------------    \nsubsorts Term IRI Keyword &lt; String .\n\nvars S : String . \n    \ncmb S : Keyword if substr(S,0,1) == \"@\" .\ncmb S : IRI     if find(S,\":\",0) =/= notFound .\ncmb S : Term    if find(S,\":\",0) == notFound /\\ substr(S,0,1) =/= \"@\" .    \n\n---------------------------------------------\nsorts Context_Entry Context_Entry+ Context_Entry* .\n---------------------------------------------\nsubsorts Context_Entry &lt; Context_Entry+ &lt; Context_Entry* .    \n\nsubsort Context_Entry  &lt; Entry .    \nsubsort Context_Entry+ &lt; Entry+ .    \nsubsort Context_Entry* &lt; Entry* .  \n            \nmb T:Term : V:Value  : Context_Entry .   \n\nop _,_ : Context_Entry* Context_Entry* -&gt; Context_Entry* [ditto] .\nop _,_ : Context_Entry* Context_Entry+ -&gt; Context_Entry+ [ditto] .                    \n\nvars E : Entry . var CE* : Context_Entry* .\ncmb E : Context_Entry if \"@context\" : { CE* } := E .  \n\n---  Context semantics:    \n\nvars T   : Term .\nvars Iri : IRI .\nvars V   : Value . \nvars ... : Entry* .\n    \neq { \"@context\" : { T : Iri }, T : V, ...} = { \"@context\" : { T : Iri }, Iri : V, ...} .\n\n---------------------\nsort Identity_Entry .\n---------------------    \nsubsort Identity_Entry &lt; Entry .\n    \ncmb E : Identity_Entry if \"@id\" : Iri := E .\n\n----------------- \nsort Type_Entry .\n-----------------\nsubsort Type_Entry &lt; Entry .\n\ncmb E : Type_Entry if \"@type\" : Iri := E .\nendfm\n\nshow modules .\n\n\n\nJSON-LD_TERM\nfmod JSON-LD-TERM is sort Term . sort Identifier . sort Context ,\nsubsorts Context &lt; Object .\nop expands : Term Context -&gt; Identifier .\n\n\nsubsort NodeObject NodeObject* &lt; Json-ld &lt; Json .\n\nmb { \"context\" : Value } : JsonLd .\nmb { \"@graph\"  : Value } : JsonLd .\nmb { \"@context\" : Value , \"@graph\" ; Value } : JsonLd ,\n\nNodeObject &lt; Object .    \n    \n    \n%%maude red “@context” .\nred “pepe” .\nred\n%%maude — Example 4 red “@context” : { “name” : “http://schema.org/name”, “image” : { “@id” : “http://schema.org/image”, “@type” : “@id” } } .\n%%maude red { “@context” : { “name” : “http://schema.org/name” }, “name” : “Manu Sporny”, “status” : “trollin’” } .\n\n\nHTML",
    "crumbs": [
      "maude-magic"
    ]
  },
  {
    "objectID": "maude-magic.html#to-do",
    "href": "maude-magic.html#to-do",
    "title": "maude-magic",
    "section": "TO-DO",
    "text": "TO-DO\n\nRemove trailibg newlines grom cell.\nA command that ads a path to MAUDE_LIB\nImplementar el poder acceder al Intérprete de maude Hacer un comando %maude shell de manera que haciendo la asignación\nmaude_shell = %maude shell\ntengamos acceso a la instancia del intérprete de la shell",
    "crumbs": [
      "maude-magic"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "maude-magic",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "maude-magic"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "maude-magic",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall maude_magic in Development mode\n# make sure maude_magic package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to maude_magic\n$ nbdev_prepare",
    "crumbs": [
      "maude-magic"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "maude-magic",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/jsm65fenoll/maude-magic.git\nor from conda\n$ conda install -c jsm65fenoll maude_magic\nor from pypi\n$ pip install maude_magic\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "maude-magic"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "maude-magic",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2",
    "crumbs": [
      "maude-magic"
    ]
  }
]